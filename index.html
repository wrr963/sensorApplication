<!DOCTYPE html>
<html>
<head>
    <title>3D スマホ加速度ビューア</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        /* CSSは変更なし */
        body { font-family: 'Segoe UI', sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; margin: 0; background-color: #f0f2f5; color: #333; overflow: hidden; }
        h1 { color: #2c3e50; margin-bottom: 20px; }
        .sensor-data { margin-bottom: 30px; text-align: center; background-color: #ffffff; padding: 20px 30px; border-radius: 10px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1); }
        .sensor-data p { margin: 5px 0; font-size: 1.1em; font-weight: bold; }
        .sensor-data span { display: inline-block; width: 80px; text-align: right; color: #007bff; }
        #threejsContainer { border: 2px solid #ddd; background-color: #ffffff; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1); border-radius: 10px; }
        .error-message { color: #e74c3c; font-weight: bold; margin-top: 20px; text-align: center; }
        .info-message { margin-top: 20px; color: #666; font-size: 0.9em; text-align: center; }
        button { background-color: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 1em; margin-top: 15px; }
        #permissionPrompt { display: flex; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); color: white; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; text-align: center; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.150.1/three.min.js"></script>
</head>
<body>
    <h1>3D スマホ加速度ビューア</h1>
    <div class="sensor-data">
        <p>X軸: <span id="x-axis">0.00</span> m/s²</p>
        <p>Y軸: <span id="y-axis">0.00</span> m/s²</p>
        <p>Z軸: <span id="z-axis">0.00</span> m/s²</p>
        <p>合計: <span id="magnitude">0.00</span> m/s²</p>
    </div>
    <div id="threejsContainer" style="width: 300px; height: 300px;"></div>
    <div id="errorMessage" class="error-message" style="display: none;"></div>
    <div class="info-message"><p>※ このアプリはHTTPS接続でのみ動作します。</p></div>
    <div id="permissionPrompt">
        <h2>センサーアクセスを許可</h2>
        <p>デバイスの動きと向きのセンサーを使用します。</p>
        <button id="requestPermissionButton">許可する</button>
    </div>

    <script>
        // DOM要素とThree.jsの基本設定 (変更なし)
        const xAxisElement = document.getElementById('x-axis'), yAxisElement = document.getElementById('y-axis'), zAxisElement = document.getElementById('z-axis'), magnitudeElement = document.getElementById('magnitude'), errorMessageElement = document.getElementById('errorMessage'), permissionPrompt = document.getElementById('permissionPrompt'), requestPermissionButton = document.getElementById('requestPermissionButton'), threejsContainer = document.getElementById('threejsContainer');
        let magnitude = 0;
        let currentAcceleration = { x: 0, y: 0, z: 0 };
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, 300 / 300, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(300, 300);
        threejsContainer.appendChild(renderer.domElement);
        scene.add(new THREE.AmbientLight(0x404040));
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0, 1, 1).normalize();
        scene.add(directionalLight);
        const phoneGeometry = new THREE.BoxGeometry(0.5, 0.1, 1.0);
        const phoneMaterial = new THREE.MeshPhongMaterial({ color: 0x8888ff, transparent: true, opacity: 0.7 });
        const phoneMesh = new THREE.Mesh(phoneGeometry, phoneMaterial);
        scene.add(phoneMesh);
        const accelerationArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), 0.5, 0xff0000);
        phoneMesh.add(accelerationArrow);
        camera.position.z = 2;

        function showError(message) {
            errorMessageElement.textContent = message;
            errorMessageElement.style.display = 'block';
        }

        // ★ 変更点：センサー初期化処理にフォールバックを追加
        function initSensors() {
            let orientationInitialized = false;

            // --- 向きセンサー：まず最新APIを試す ---
            try {
                const orientationSensor = new AbsoluteOrientationSensor({ frequency: 60 });
                orientationSensor.addEventListener('reading', () => {
                    phoneMesh.quaternion.fromArray(orientationSensor.quaternion).normalize();
                    orientationInitialized = true;
                });
                orientationSensor.addEventListener('error', (event) => {
                    // このセンサーがエラーになったらフォールバックを試す
                    console.error("AbsoluteOrientationSensor Error:", event.error.name, event.error.message);
                    if (!orientationInitialized) {
                        useOldOrientationAPI();
                    }
                });
                orientationSensor.start();
            } catch (error) {
                console.warn("AbsoluteOrientationSensor not supported or failed:", error.message);
                // try-catchでエラーになったらフォールバックを試す
                if (!orientationInitialized) {
                    useOldOrientationAPI();
                }
            }

            // --- 向きセンサー：フォールバック用の古いAPI ---
            function useOldOrientationAPI() {
                console.log("Falling back to DeviceOrientationEvent.");
                const deviceOrientationControls = new DeviceOrientationControls(phoneMesh);
                // 内部で 'deviceorientation' イベントをリッスンし、phoneMesh.quaternionを更新
                // ただし、アニメーションループ内でcontrols.update()を呼ぶ必要がある
                window.deviceOrientationControls = deviceOrientationControls;
            }


            // --- 加速度センサー (変更なし) ---
            try {
                const accSensor = new LinearAccelerationSensor({ frequency: 60 });
                accSensor.addEventListener('reading', () => {
                    currentAcceleration = { x: accSensor.x || 0, y: accSensor.y || 0, z: accSensor.z || 0 };
                    magnitude = Math.sqrt(currentAcceleration.x**2 + currentAcceleration.y**2 + currentAcceleration.z**2);
                    xAxisElement.textContent = currentAcceleration.x.toFixed(2);
                    yAxisElement.textContent = currentAcceleration.y.toFixed(2);
                    zAxisElement.textContent = currentAcceleration.z.toFixed(2);
                    magnitudeElement.textContent = magnitude.toFixed(2);
                });
                accSensor.start();
            } catch (error) {
                showError(`加速度センサーを初期化できません: ${error.message}`);
            }
        }

        // ★ 変更点：古いAPIを補助するためのライブラリコードを追加
        // Three.jsの公式サンプルに含まれるDeviceOrientationControlsを簡略化してここに含めます
        function DeviceOrientationControls(object) {
            this.object = object;
            this.object.rotation.reorder('YXZ');
            this.enabled = true;
            this.deviceOrientation = {};
            this.screenOrientation = 0;

            const onDeviceOrientationChangeEvent = (event) => {
                this.deviceOrientation = event;
            };
            const onScreenOrientationChangeEvent = () => {
                this.screenOrientation = window.orientation || 0;
            };

            const connect = () => {
                onScreenOrientationChangeEvent();
                window.addEventListener('orientationchange', onScreenOrientationChangeEvent, false);
                window.addEventListener('deviceorientation', onDeviceOrientationChangeEvent, false);
                this.enabled = true;
            };
            connect();

            const q0 = new THREE.Quaternion();
            const q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5));
            const zee = new THREE.Vector3(0, 0, 1);
            const euler = new THREE.Euler();

            this.update = function() {
                if (this.enabled === false) return;
                const alpha = this.deviceOrientation.alpha ? THREE.MathUtils.degToRad(this.deviceOrientation.alpha) : 0;
                const beta = this.deviceOrientation.beta ? THREE.MathUtils.degToRad(this.deviceOrientation.beta) : 0;
                const gamma = this.deviceOrientation.gamma ? THREE.MathUtils.degToRad(this.deviceOrientation.gamma) : 0;
                const orient = this.screenOrientation ? THREE.MathUtils.degToRad(this.screenOrientation) : 0;

                euler.set(beta, alpha, -gamma, 'YXZ');
                this.object.quaternion.setFromEuler(euler);
                this.object.quaternion.multiply(q1);
                this.object.quaternion.multiply(q0.setFromAxisAngle(zee, -orient));
            };
        }


        // ★ 変更点：許可リクエストとアニメーションループの修正
        requestPermissionButton.addEventListener('click', () => {
            if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                DeviceMotionEvent.requestPermission().then(permissionState => {
                    if (permissionState === 'granted') {
                        initSensors();
                        permissionPrompt.style.display = 'none';
                    } else { showError('センサーへのアクセスが拒否されました。'); }
                }).catch(error => showError(`許可リクエストエラー: ${error.message}`));
            } else {
                initSensors();
                permissionPrompt.style.display = 'none';
            }
        });
        
        function animate() {
            requestAnimationFrame(animate);
            // フォールバック用の古いAPIが使われている場合、毎フレーム更新が必要
            if (window.deviceOrientationControls) {
                window.deviceOrientationControls.update();
            }
            // 加速度矢印の更新 (変更なし)
            if (magnitude > 0.1) {
                const dir = new THREE.Vector3(currentAcceleration.x, currentAcceleration.y, currentAcceleration.z).normalize();
                const arrowLength = Math.min(magnitude * 0.2, 0.8);
                accelerationArrow.setDirection(dir);
                accelerationArrow.setLength(arrowLength, 0.1, 0.05);
                accelerationArrow.visible = true;
            } else {
                accelerationArrow.visible = false;
            }
            renderer.render(scene, camera);
        }

        window.addEventListener('load', () => {
            if (typeof DeviceMotionEvent === 'undefined' || typeof DeviceMotionEvent.requestPermission !== 'function') {
                 permissionPrompt.style.display = 'none';
                 initSensors();
            }
            animate();
        });
    </script>
</body>
</html>